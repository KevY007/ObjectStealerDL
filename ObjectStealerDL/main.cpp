#include "main.h"

DWORD				g_SAMP = NULL;
HANDLE				g_DllHandle;

struct eMaterialData
{
	UINT8 MaterialType;
	UINT8 MaterialID;

	// Text Textures
	UINT8 MaterialSize;
	char fontName[128];
	UINT8 FontSize;
	char Text[128];
	UINT8 Bold;
	DWORD FontColor;
	DWORD BackgroundColor;
	UINT8 Align;

	// Normal Textures
	UINT16 ModelID;
	char libraryName[128];
	char textureName[128];
	DWORD color;
};

struct eObjectData
{
	bool Locked = false;

	UINT16 wObjectID;
	UINT32 ModelID;
	float x;
	float y;
	float z;
	float rotx;
	float roty;
	float rotz;
	float DrawDistance;
	UINT8 NoCameraCol;
	UINT16 attachedObject;
	UINT16 attachedVehicle;
	float AttachOffsetX;
	float AttachOffsetY;
	float AttachOffsetZ;
	float AttachRotX;
	float AttachRotY;
	float AttachRotZ;
	UINT8 SyncRotation;

	eMaterialData MaterialData[64] = { 0 };
};

struct eRemoveBuildingParams
{
	UINT32 dObjectModel;
	float x;
	float y;
	float z;
	float radius;
};

struct eCustomModels
{
	INT32 index;
	INT32 unknown;
	UINT8 type; // type: 1 = Skin, 2 = Model.
	INT32 virtualworld;
	INT32 baseId;
	INT32 newId; // AKA OBJECT ID IN THE SERVER'S SCRIPT OR SMTH, LIKE TO BE USED WITH CREATEOBJECT(newId as the model);
	INT32 dffcrc;
	INT32 txdcrc;
	INT32 dffsize;
	INT32 txdsize;
	UINT8 timeon; // If model isn't timed, timeon and timeoff must be 0.
	UINT8 timeoff;
};

typedef enum { NONE, ADDOBJECT, ADDMATERIAL, REMOVEOBJECT } QUEUETYPE;

struct QueueData
{
	QUEUETYPE type = NONE;

	eObjectData object = { 0 };

	UINT16 removeObjectID = -1;

	struct
	{
		eMaterialData mData = { 0 };
		int objectID = -1;
		int tries = 0;
	} MaterialData;
};

std::vector<eObjectData> Objects;
std::vector<eRemoveBuildingParams> RemoveBuildings;
std::vector<eCustomModels> CustomModels;

DWORD ulTickObjectAdd = 0;

bool g_ModelsDownloaded = true;

bool UseDynamicObjects = true;
float RemoveBuildingDist = 100.0;
bool SaveLoadedOnly = false;

moodycamel::ConcurrentQueue<QueueData> QueuePrc;

string GetHexFromInt(UINT32 value, bool addOX)
{
	std::stringstream ss;
	string full;
	string result;
	
	ss << std::hex << value;
	result = ss.str();

	transform(result.begin(), result.end(), result.begin(), ::toupper);

	if (addOX)
		full = "0x";

	full.append(result);

	return full;
}

bool sCopyFile(string from, string to)
{
	std::ifstream  src(from, std::ios::binary);
	std::ofstream  dst(to, std::ios::binary);

	if (!src.is_open() || !dst.is_open())
	{
		src.close();
		dst.close();
		return false;
	}

	dst << src.rdbuf();

	src.close();
	dst.close();

	return true;
}

std::string GetSystemFolderPaths(int csidl)
{
	wchar_t Folder[1024];
	HRESULT hr = SHGetFolderPathW(0, csidl, 0, 0, Folder);
	if (SUCCEEDED(hr))
	{
		char str[1024];
		wcstombs(str, Folder, 1023);
		return str;
	}
	else return "";
}

UINT32 RGBAtoARGB(UINT32 col)
{
	return (col >> 8) | (col << 24);
}

UINT32 ARGBtoABGR(UINT32 col) // Converts ARGB to ABGR
{
	//Normally col = 0xffa5a7a4
	//Target/script = 0xFFA4A7A5
	//To achieve: 0xffa4a7a5 (swap R and B)

	int r = (col >> 16) & 0xFF;
	int b = col & 0xFF;
	return (col & 0xFF00FF00) | (b << 16) | r;
}

void SaveObjects(string name, float dist = 0.0F)
{
	string filename = name + "\\" + "objects.txt";
	if (CreateDirectory(name.c_str(), NULL))
	{
		
	}
	else
	{
		return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Failed to create the directory for objects.");
	}

	std::ofstream ofs;
	ofs.open(filename, std::ofstream::out | std::ofstream::app);

	if (!ofs.is_open())
		return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Failed to open the file \"%s\", is the name valid?", filename.c_str());

	std::ofstream building_file;
	building_file.open(name + "\\" + "buildings.txt", std::ofstream::out | std::ofstream::app);

	if (!building_file.is_open())
		return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Failed to open the file \"%s\", is the name valid?", string(name + "\\" + "buildings.txt").c_str());
	
	
	std::ofstream model_file;
	model_file.open(name + "\\" + "models.txt", std::ofstream::out | std::ofstream::app);

	if (!model_file.is_open())
		return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Failed to open the file \"%s\", is the name valid?", string(name + "\\" + "model.txt").c_str());


	addMessageToChatWindow(D3DCOLOR_XRGB(0, 220, 51), "Saving Objects... (DO NOT QUIT, PAUSE OR TAB)");


	int count = 0;
	int buildings_count = 0;
	int texture_texts = 0;
	int models_count = 0;
	char snBuffer[1024] = { 0 };

	std::vector<eRemoveBuildingParams> buildings;
	std::vector<eCustomModels> models;

	ofs << endl << "/* Generated by KevY aka 0x32789's Object Stealer */" << endl;

	ofs << endl << "new g_tmpObjID;" << endl;

	if (UseDynamicObjects)
	{
		ofs << endl << "new g_tmpObjVw = -1, g_tmpObjInt = -1;" << endl;
	}

	struct actor_info* self = actor_info_get();
	float pos[3];
	vect3_copy(&self->base.matrix[4 * 3], pos);

	for (std::vector<eObjectData>::iterator it = Objects.begin(); it != Objects.end(); ++it)
	{
		int index = std::distance(Objects.begin(), it);

		if (dist >= 0.9F)
		{
			double objdist = hypot(hypot(Objects[index].x - pos[0], Objects[index].y - pos[1]), Objects[index].z - pos[2]);

			if (objdist > dist) continue;
		}

		for (std::vector<eRemoveBuildingParams>::iterator itz = RemoveBuildings.begin(); itz != RemoveBuildings.end(); ++itz)
		{
			int index2 = std::distance(RemoveBuildings.begin(), itz);
			double distance = hypot(hypot(Objects[index].x - RemoveBuildings[index2].x, Objects[index].y - RemoveBuildings[index2].y), 
				Objects[index].z - RemoveBuildings[index2].z);

			if (distance <= RemoveBuildingDist)
			{
				bool found = false;

				if (buildings.size() > 0)
				{
					for (auto& current : buildings)
					{
						if (current.dObjectModel == RemoveBuildings[index2].dObjectModel &&
							current.x == RemoveBuildings[index2].x &&
							current.y == RemoveBuildings[index2].y &&
							current.z == RemoveBuildings[index2].z && current.radius == RemoveBuildings[index2].radius)
						{
							found = true;
							break;
						}
					}
				}

				if (!found)
				{
					buildings_count++;
					buildings.push_back(RemoveBuildings[index2]);
				}
			}
		}

		for (std::vector<eCustomModels>::iterator itz = CustomModels.begin(); itz != CustomModels.end(); ++itz)
		{
			int index2 = std::distance(CustomModels.begin(), itz);
			if (CustomModels[index2].newId == Objects[index].ModelID)
			{
				bool found = false;

				if (models.size() > 0)
				{
					for (auto& current : models)
					{
						if (current.newId == CustomModels[index2].newId && 
							current.virtualworld == CustomModels[index2].virtualworld && 
							current.txdcrc == CustomModels[index2].txdcrc && 
							current.dffcrc == CustomModels[index2].dffcrc)
						{
							found = true;
							break;
						}
					}
				}

				if (!found)
				{
					models_count++;
					models.push_back(CustomModels[index2]);
				}
			}
		}

		if(!UseDynamicObjects)
			sprintf(snBuffer, "CreateObject(%d, %0.6f, %0.6f, %0.6f, %0.6f, %0.6f, %0.6f);",
				Objects[index].ModelID, Objects[index].x, Objects[index].y, Objects[index].z, Objects[index].rotx, Objects[index].roty, Objects[index].rotz);
		else
			sprintf(snBuffer, "CreateDynamicObject(%d, %0.6f, %0.6f, %0.6f, %0.6f, %0.6f, %0.6f, g_tmpObjVw, g_tmpObjInt);",
				Objects[index].ModelID, Objects[index].x, Objects[index].y, Objects[index].z, Objects[index].rotx, Objects[index].roty, Objects[index].rotz);


		ofs << "g_tmpObjID = " << snBuffer << endl;

		for (int matID = 0; matID < 64; matID++)
		{
			if (Objects[index].MaterialData[matID].MaterialType == 1 && Objects[index].MaterialData[matID].MaterialID != -1)
			{
				if (!UseDynamicObjects)
					sprintf(snBuffer, "SetObjectMaterial(g_tmpObjID, %d, %d, \"%s\", \"%s\", %#x);",
						Objects[index].MaterialData[matID].MaterialID, Objects[index].MaterialData[matID].ModelID, Objects[index].MaterialData[matID].libraryName, Objects[index].MaterialData[matID].textureName,
						ARGBtoABGR(Objects[index].MaterialData[matID].color));
				else
					sprintf(snBuffer, "SetDynamicObjectMaterial(g_tmpObjID, %d, %d, \"%s\", \"%s\", %#x);",
						Objects[index].MaterialData[matID].MaterialID, Objects[index].MaterialData[matID].ModelID, Objects[index].MaterialData[matID].libraryName, Objects[index].MaterialData[matID].textureName,
						ARGBtoABGR(Objects[index].MaterialData[matID].color));

				ofs << snBuffer << endl;
				texture_texts++;
			}
			else if (Objects[index].MaterialData[matID].MaterialType == 2 && Objects[index].MaterialData[matID].MaterialID != -1)
			{
				if (!UseDynamicObjects)
					sprintf(snBuffer, "SetObjectMaterialText(g_tmpObjID, \"%s\", %d, %d, \"%s\", %d, %d, %#x, %#x, %d);",
						Objects[index].MaterialData[matID].Text, Objects[index].MaterialData[matID].MaterialID, Objects[index].MaterialData[matID].MaterialSize,
						Objects[index].MaterialData[matID].fontName, Objects[index].MaterialData[matID].FontSize, Objects[index].MaterialData[matID].Bold,
						ARGBtoABGR(Objects[index].MaterialData[matID].FontColor), ARGBtoABGR(Objects[index].MaterialData[matID].BackgroundColor), Objects[index].MaterialData[matID].Align);
				else
					sprintf(snBuffer, "SetDynamicObjectMaterialText(g_tmpObjID, %d, \"%s\", %d, \"%s\", %d, %d, %#x, %#x, %d);",
						Objects[index].MaterialData[matID].MaterialID, Objects[index].MaterialData[matID].Text, Objects[index].MaterialData[matID].MaterialSize,
						Objects[index].MaterialData[matID].fontName, Objects[index].MaterialData[matID].FontSize, Objects[index].MaterialData[matID].Bold,
						ARGBtoABGR(Objects[index].MaterialData[matID].FontColor), ARGBtoABGR(Objects[index].MaterialData[matID].BackgroundColor), Objects[index].MaterialData[matID].Align);

				ofs << snBuffer << endl;
				texture_texts++;
			}	
		}
		count++;
	}

	building_file << endl;

	for (std::vector<eRemoveBuildingParams>::iterator itz = buildings.begin(); itz != buildings.end(); ++itz)
	{
		int index2 = std::distance(buildings.begin(), itz);
		sprintf(snBuffer, "RemoveBuildingForPlayer(playerid, %d, %0.6f, %0.6f, %0.6f, %0.3f);",
			buildings[index2].dObjectModel, buildings[index2].x, buildings[index2].y, buildings[index2].z, buildings[index2].radius);

		building_file << snBuffer << endl;
	}

	for (std::vector<eCustomModels>::iterator itz = models.begin(); itz != models.end(); ++itz)
	{
		int index2 = std::distance(models.begin(), itz);
		string dffname = GetHexFromInt(models[index2].dffcrc, true);
		dffname.append(".dff");

		string txdname = GetHexFromInt(models[index2].txdcrc, true);
		txdname.append(".txd");

		bool copy = false;

		if (models[index2].timeoff != 0 || models[index2].timeon != 0)
		{
			sprintf(snBuffer, "AddSimpleModelTimed(%d, %d, %d, \"%s\", \"%s\", %d, %d);",
				models[index2].virtualworld, models[index2].baseId, models[index2].newId, dffname.c_str(), txdname.c_str(), models[index2].timeon, models[index2].timeoff);

			copy = true;
		}
		else
		{
			sprintf(snBuffer, "AddSimpleModel(%d, %d, %d, \"%s\", \"%s\");",
				models[index2].virtualworld, models[index2].baseId, models[index2].newId, dffname.c_str(), txdname.c_str());

			copy = true;
		}

		if (copy)
		{
			string path = GetSystemFolderPaths(CSIDL_MYDOCUMENTS);
			path.append("\\GTA San Andreas User Files\\SAMP\\cache\\");
			path.append(g_stSAMP->szIP);
			path.append("." + to_string(g_stSAMP->ulPort) + "\\");

			if (!sCopyFile(path + dffname, name + "\\" + dffname))
				addMessageToChatWindow(D3DCOLOR_XRGB(220, 10, 10), "[MODEL] Failed to copy from %s to %s.", 
					(path + dffname).c_str(), (name + "\\" + dffname).c_str());

			if (!sCopyFile(path + txdname, name + "\\" + txdname))
				addMessageToChatWindow(D3DCOLOR_XRGB(220, 10, 10), "[MODEL] Failed to copy from %s to %s.",
				(path + txdname).c_str(), (name + "\\" + txdname).c_str());
		}

		model_file << snBuffer << endl;
	}

	ofs.close();
	model_file.close();
	building_file.close();
	 
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "");
	Sleep(200);

	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "====[{FF0000}OBJECT STEALER REPORT{FFFFFF}]====");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Folder: {F5BE19}\"%s\"", name.c_str());
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Objects: {F5BE19}%d", count);
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "ObjectMaterials/Texts: {F5BE19}%d", texture_texts);
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Remove Buildings: {F5BE19}%d", buildings_count);
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Custom Models: {F5BE19}%d", models_count);
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Dynamic Objects (Streamer): %s", UseDynamicObjects ? "{00FF33}Yes" : "{FF0000}No");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Virtual World & Interior: {F5BE19}-1 & -1 (Edit in objects.txt)");

	if(dist >= 0.9F) 
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "Saved Objects X Meters Of You: {F5BE19}%f", dist);


	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{968D8D}Only RemoveBuildings within %0.2f meters of objects proximity were saved!", RemoveBuildingDist, count, filename.c_str());
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{A1F519}Made by 0x32789 (KevY), show some love!");

	Sleep(200);
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "");
	


	return;
}


void cmd_objlist(char* param)
{
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00FF33}Total Objects Recorded: %d", Objects.size());
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00FF33}Total RemoveBuildings Recorded: %d", RemoveBuildings.size());
}

void cmd_resetobjs(char* param)
{
	Objects.clear();
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00FF33}Resetted all objects. (New size: %d)", Objects.size());
}

void cmd_objsettings(char* parc)
{
	if (strlen(parc) <= 2 || parc == nullptr) return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{CCCCCC}/objectsettings {1E9913}[dynamicobject/buildingdist/onlyloaded]");

	std::stringstream s(parc);

	std::string first, second, three;
	s >> first >> second >> three;

	if (first.find("dynamicobject") != string::npos)
	{
		UseDynamicObjects = !UseDynamicObjects;
		if (UseDynamicObjects)
		{
			addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{1e9913}[#] {FFFFFF}Will save as Dynamic Objects now.");
		}
		else addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{ff6347}[#] {FFFFFF}Will not save as Dynamic Objects but normal Objects now.");

	}
	else if (first.find("buildingdist") != string::npos)
	{
		if (second.empty())
			return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{CCCCCC}/objectsettings buildingdist{1E9913} [distance]");

		RemoveBuildingDist = stof(second);

		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00FF33}Buildings %0.2f meters close to the objects will be removed.", RemoveBuildingDist);
	}
	else if (first.find("onlyloaded") != string::npos)
	{
		SaveLoadedOnly = !SaveLoadedOnly;
		if (SaveLoadedOnly)
		{
			addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{1e9913}[#] {FFFFFF}Will save ONLY streamed objects now.");
		}
		else addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{ff6347}[#] {FFFFFF}Will save ALL streamed and old objects now.");

	}
	else cmd_objsettings(""); // This will show the USAGE as strlen(parc) <= 1

	return;
}

void cmd_saveobjsnear(char* param)
{
	if (Objects.size() < 1) return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "No objects have been recorded yet!");

	char args[128];
	float dist;

	int ipc = sscanf(param, "%f %[^\n]s", &dist, args);

	if (!g_ModelsDownloaded && strcmp(args, "forceyes") != 0)
	{
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 0, 0), "Models have not been downloaded! This is not safe to try this while still downloading?");
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "You can use /saveobjectsnear forceyes to continue saving with a random file name.");
		return;
	}

	if (ipc == 1 || strcmp(args, "forceyes") == 0)
	{
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00CCFF}You can also /saveobjectsnear [file name], choosing a random name for now.");

		std::time_t t = std::time(0);

		sprintf(args, "objects_%d", (int)t - 1500000000);
	}
	else if(ipc != 2)
	{
		return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{999999}/saveobjectsnear [distance] [optional: foldername]");
	}


	std::thread(SaveObjects, string(args), dist).detach();
}

void cmd_saveobjs(char* param) 
{
	if (Objects.size() < 1) return addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "No objects have been recorded yet!");

	char args[128];

	int ipc = sscanf(param, "%[^\n]s", args);

	if (!g_ModelsDownloaded && strcmp(args, "forceyes") != 0)
	{
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 0, 0), "Models have not been downloaded! This is not safe to try this while still downloading?");
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "You can use /saveobjects forceyes to continue saving with a random file name.");
		return;
	}

	if (ipc < 1 || strcmp(args, "forceyes") == 0)
	{
		addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00CCFF}You can also /saveobjects [file name], choosing a random name for now.");

		std::time_t t = std::time(0);

		sprintf(args, "objects_%d", (int)t - 1500000000);
	}


	std::thread(SaveObjects, string(args), 0.0F).detach();
}

void QueueProcessor()
{
	std::vector<QueueData> PushList;
	while (true)
	{
		QueueData q;
		bool found = QueuePrc.try_dequeue(q);

		if (found)
		{
			if (q.type == QUEUETYPE::ADDMATERIAL)
			{
				if (q.MaterialData.mData.MaterialType == 1 || q.MaterialData.mData.MaterialType == 2)
				{
					bool done = false;
					for (std::vector<eObjectData>::iterator it = Objects.begin(); it != Objects.end(); ++it)
					{
						int index = std::distance(Objects.begin(), it);
						if (Objects[index].wObjectID == q.MaterialData.objectID && Objects[index].wObjectID != -1 && !Objects[index].Locked)
						{
							if (q.MaterialData.mData.MaterialType == 1)
							{
								int freeID = -1;

								for (int i = 0; i < 64; i++)
								{
									if ((Objects[index].MaterialData[i].MaterialType == -1 || Objects[index].MaterialData[i].MaterialType == 255) && freeID == -1)
									{
										freeID = i;
									}

									if (Objects[index].MaterialData[i].MaterialType == q.MaterialData.mData.MaterialType &&
										Objects[index].MaterialData[i].ModelID == q.MaterialData.mData.ModelID &&
										strcmp(Objects[index].MaterialData[i].libraryName, q.MaterialData.mData.libraryName) == 0 &&
										strcmp(Objects[index].MaterialData[i].textureName, q.MaterialData.mData.textureName) == 0 &&
										Objects[index].MaterialData[i].color == q.MaterialData.mData.color &&
										Objects[index].MaterialData[i].MaterialID == q.MaterialData.mData.MaterialID)
									{
										freeID = -1;
										break;
									}
								}

								if (freeID != -1)
								{
									Objects[index].MaterialData[freeID].MaterialType = 1;
									Objects[index].MaterialData[freeID].MaterialID = q.MaterialData.mData.MaterialID;
									Objects[index].MaterialData[freeID].ModelID = q.MaterialData.mData.ModelID;
									Objects[index].MaterialData[freeID].color = q.MaterialData.mData.color;
									strcpy(Objects[index].MaterialData[freeID].textureName, q.MaterialData.mData.textureName);
									strcpy(Objects[index].MaterialData[freeID].libraryName, q.MaterialData.mData.libraryName);
								}
							}
							else if (q.MaterialData.mData.MaterialType == 2)
							{
								int freeID = -1;

								for (int i = 0; i < 64; i++)
								{
									if ((Objects[index].MaterialData[i].MaterialType == -1 || Objects[index].MaterialData[i].MaterialType == 255) && freeID == -1)
									{
										freeID = i;
									}

									if (Objects[index].MaterialData[i].MaterialType == q.MaterialData.mData.MaterialType &&
										Objects[index].MaterialData[i].Align == q.MaterialData.mData.Align &&
										Objects[index].MaterialData[i].BackgroundColor == q.MaterialData.mData.BackgroundColor &&
										Objects[index].MaterialData[i].Bold == q.MaterialData.mData.Bold &&
										Objects[index].MaterialData[i].MaterialSize == q.MaterialData.mData.MaterialSize &&
										strcmp(Objects[index].MaterialData[i].fontName, q.MaterialData.mData.fontName) == 0 &&
										Objects[index].MaterialData[i].FontSize == q.MaterialData.mData.FontSize &&
										strcmp(Objects[index].MaterialData[i].Text, q.MaterialData.mData.Text) == 0 &&
										Objects[index].MaterialData[i].MaterialID == q.MaterialData.mData.MaterialID)
									{
										freeID = -1;
										break;
									}
								}

								if (freeID != -1)
								{
									Objects[index].MaterialData[freeID].MaterialType = 2;
									Objects[index].MaterialData[freeID].MaterialID = q.MaterialData.mData.MaterialID;
									Objects[index].MaterialData[freeID].MaterialSize = q.MaterialData.mData.MaterialSize;
									strcpy(Objects[index].MaterialData[freeID].fontName, q.MaterialData.mData.fontName);
									Objects[index].MaterialData[freeID].FontSize = q.MaterialData.mData.FontSize;
									Objects[index].MaterialData[freeID].Bold = q.MaterialData.mData.Bold;
									Objects[index].MaterialData[freeID].FontColor = q.MaterialData.mData.FontColor;
									Objects[index].MaterialData[freeID].BackgroundColor = q.MaterialData.mData.BackgroundColor;
									Objects[index].MaterialData[freeID].Align = q.MaterialData.mData.Align;
									strcpy(Objects[index].MaterialData[freeID].Text, q.MaterialData.mData.Text);
								}
							}
							done = true;
							break;
						}
					}
					if (!done && q.MaterialData.tries <= 10)
					{
						if (GetTickCount() - ulTickObjectAdd >= 3000)
						{
							q.MaterialData.tries++;
						}
	
						PushList.push_back(q);
					}
				}
			}
			else if (q.type == QUEUETYPE::ADDOBJECT)
			{
				bool canItSave = true;

				for (std::vector<eObjectData>::iterator it = Objects.begin(); it != Objects.end(); ++it)
				{
					int index = std::distance(Objects.begin(), it);
					if (
						Objects[index].x == q.object.x && Objects[index].y == q.object.y && Objects[index].z == q.object.z &&
						Objects[index].rotx == q.object.rotx && Objects[index].roty == q.object.roty && Objects[index].rotz == q.object.rotz &&
						Objects[index].ModelID == q.object.ModelID)
					{
						canItSave = false;
					}
				}

				if (canItSave)
				{
					q.object.Locked = false;
					Objects.push_back(q.object);
				}
				ulTickObjectAdd = GetTickCount();
			}
			else if (q.type == QUEUETYPE::REMOVEOBJECT)
			{
				std::vector<int> indexErases;

				for (std::vector<eObjectData>::iterator it = Objects.begin(); it != Objects.end(); ++it)
				{
					int index = std::distance(Objects.begin(), it);
					if (Objects[index].wObjectID == q.removeObjectID && !Objects[index].Locked)
					{
						indexErases.push_back(index);
						Objects[index].Locked = true;
					}
				}
				
				if (SaveLoadedOnly)
				{
					for each (int index in indexErases)
					{
						Objects.erase(Objects.begin() + index);
					}
				}
			}
		}

		for each (auto qd in PushList)
		{
			QueuePrc.enqueue(qd);
		}
		PushList.clear();
	}
	return;
}

void cmd_testcmdobj(char* params)
{
	
	return;
}

void cmd_objcmds(char* params)
{
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/objectlist - Shows the number of objects recorded.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/saveobjects - Save's all recorded objects yet.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/objcmds - Brings up this very information you are viewing.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/saveobjectsnear - Saves objects only X distance near you.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/resetobjects - Reset's all objects recorded.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/objectsettings - Allows you to set some settings for object recording.");
	addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "/testcmdobj - Testing Cmd, No Use.");
	return;
}

void ThrMainFS() 
{
	while (g_SAMP == NULL || g_Chat == NULL)
	{
		g_SAMP = (DWORD)GetModuleHandle("samp.dll");

		g_Chat = stGetSampChatInfo();
		Sleep(1000);
	}
	
	bool initSampRak = false;
	while (true)
	{
		if (!initSampRak)
		{
			g_stSAMP = stGetSampInfo();

			if (isBadPtr_writeAny(g_stSAMP, sizeof(stSAMP)))
			{
				continue;
			}

			if (isBadPtr_writeAny(g_stSAMP->pPools, sizeof(stSAMPPools)))
			{
				continue;
			}

			g_Chat = stGetSampChatInfo();
			if (isBadPtr_writeAny(g_Chat, sizeof(stChatInfo)))
			{
				continue;
			}

			g_Input = stGetInputInfo();
			if (isBadPtr_writeAny(g_Input, sizeof(stInputInfo)))
			{
				continue;
			}

			if (g_stSAMP->pRakClientInterface == NULL)
			{
				continue;
			}

			g_RakClient = new RakClient(g_stSAMP->pRakClientInterface);
			g_stSAMP->pRakClientInterface = new HookedRakClientInterface();

			SetupSAMPHook("HandleRPCPacket", SAMP_HOOKENTER_HANDLE_RPC, hook_handle_rpc_packet, DETOUR_TYPE_JMP, 6, "FF5701");
			SetupSAMPHook("HandleRPCPacket2", SAMP_HOOKENTER_HANDLE_RPC2, hook_handle_rpc_packet2, DETOUR_TYPE_JMP, 8, "FF5701");
			SetupSAMPHook("CNETGAMEDESTR1", SAMP_HOOKENTER_CNETGAME_DESTR, CNetGame__destructor, DETOUR_TYPE_CALL_FUNC, 5, "E8");
			SetupSAMPHook("CNETGAMEDESTR2", SAMP_HOOKENTER_CNETGAME_DESTR2, CNetGame__destructor, DETOUR_TYPE_CALL_FUNC, 5, "E8");

			initSampRak = true;
			addClientCommand("testcmdobj", cmd_testcmdobj);
			addClientCommand("objectlist", cmd_objlist);
			addClientCommand("saveobjects", cmd_saveobjs);
			addClientCommand("objcmds", cmd_objcmds);
			addClientCommand("saveobjectsnear", cmd_saveobjsnear);
			addClientCommand("resetobjects", cmd_resetobjs);
			addClientCommand("objectsettings", cmd_objsettings);

			ulTickObjectAdd = GetTickCount();
			std::thread(QueueProcessor).detach();

			addMessageToChatWindow(D3DCOLOR_XRGB(255, 255, 255), "{00FF33}Object Stealer DL{FFFFFF}: /objcmds");
		}
		if (initSampRak)
		{
			// Code if you wanna execute any. Put it in here so it doesn't execute before samp has loaded.
		}
		Sleep(100); // Adjust according to your needs
	}
}

bool OnSendRPC(int uniqueID, BitStream* parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
{
	if (uniqueID == RPCEnumeration::RPC_RequestSpawn) // Example
	{

	}
	return true;
}

bool OnSendPacket(BitStream* parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel)
{
	uint8_t packetId;
	parameters->ResetReadPointer();
	parameters->Read(packetId);
	
	if (packetId == PacketEnumeration::ID_BULLET_SYNC) // Example
	{

	}
	return true;
}
// and also mate4rial is mixing try not to thread them and put inside handlerpcpacketfunc?
// while queue destroy object isnt empty??
void HandleRPCPacketFunc(unsigned char id, RPCParameters* rpcParams, void(*callback) (RPCParameters*))
{
	if (rpcParams != nullptr && rpcParams->numberOfBitsOfData >= 8)
	{
		BitStream bsData(rpcParams->input, rpcParams->numberOfBitsOfData / 8, false);

		if (id == RPC_ModelData)
		{
			eCustomModels e;
			bsData.Read(e.index);
			bsData.Read(e.unknown);
			bsData.Read(e.type);
			bsData.Read(e.virtualworld);
			bsData.Read(e.baseId);
			bsData.Read(e.newId);
			bsData.Read(e.dffcrc);
			bsData.Read(e.txdcrc);
			bsData.Read(e.dffsize);
			bsData.Read(e.txdsize);
			bsData.Read(e.timeon);
			bsData.Read(e.timeoff);
			
			CustomModels.push_back(e);
		}

		if (id == RPC_SrcFinishedDownloading)
		{
			g_ModelsDownloaded = true; // Server sends this to us to let us know to hide the downloader aka when downloading is finished.
		}

		if (id == RPC_ModelFile)
		{
			g_ModelsDownloaded = false; // Means it has sent a model download request FYI.
		}

		if (id == RPC_RemoveBuildingForPlayer)
		{
			eRemoveBuildingParams e;
			bsData.Read(e.dObjectModel);
			bsData.Read(e.x);
			bsData.Read(e.y);
			bsData.Read(e.z);
			bsData.Read(e.radius);

			RemoveBuildings.push_back(e);
		}

		// TODO: ADD A FOOL PROOF AGAINST DESTROY OBJECT SO WE CAN KEEP ALL OBJECTS SAVED, LIKE WHEN OBJECT IS DESTROYED, MAKE IT UNABLE TO BE DELETED OR
		// ADDED NEW MATERIALS IN DESTROYOBJECT SO WE CAN SAVE OBJECTS THROUGHOUT THE MAP, ADD OBJECT SPECIAL ID AND ObjectData[i].Locked == true, create new obj
		if (id == RPC_DestroyObject) // BRUH I FORGOT TO ADD THIS AND TEXTURES OF OBJECTS WERE LITERALLY OVERLAPPING CAUSE OF STREAMER PLUGIN HAHA
		{
			UINT16 wObjectID;
			bsData.Read(wObjectID);
			
			QueueData q;
			q.type = REMOVEOBJECT;
			q.removeObjectID = wObjectID;
			QueuePrc.enqueue(q);
		}

		if(id == RPC_CreateObject)
		{
			eObjectData object;
			memset(&object, 0, sizeof object);
			bsData.Read(object.wObjectID);

			bsData.Read(object.ModelID);
			bsData.Read(object.x);
			bsData.Read(object.y);
			bsData.Read(object.z);
			bsData.Read(object.rotx);
			bsData.Read(object.roty);
			bsData.Read(object.rotz);
			bsData.Read(object.DrawDistance);
			bsData.Read(object.NoCameraCol);
			bsData.Read(object.attachedObject);
			bsData.Read(object.attachedVehicle);
			bsData.Read(object.AttachOffsetX);
			bsData.Read(object.AttachOffsetY);
			bsData.Read(object.AttachOffsetZ);
			bsData.Read(object.AttachRotX);
			bsData.Read(object.AttachRotY);
			bsData.Read(object.AttachRotZ);
			bsData.Read(object.SyncRotation);

			memset(&object.MaterialData, 0, sizeof object.MaterialData);
			for (int i = 0; i < 64; i++)
			{
				memset(&object.MaterialData[i], 0, sizeof object.MaterialData[i]);
				object.MaterialData[i].MaterialType = -1;
				object.MaterialData[i].ModelID = -1;
				object.MaterialData[i].MaterialID = -1;
			}
			
			if (object.x != 0.0 && object.y != 0.0 && object.z != 0.0)
			{
				QueueData q;

				q.type = ADDOBJECT;

				q.object = object;

				QueuePrc.enqueue(q);
			}
		}

		if (id == RPC_SetObjectMaterial)
		{
			QueueData q;

			q.type = ADDMATERIAL;

			q.MaterialData.tries = 0;

			UINT16 objectID;
			bsData.Read(objectID);
			q.MaterialData.objectID = objectID;

			UINT8 MaterialType;
			bsData.Read(MaterialType);
			q.MaterialData.mData.MaterialType = MaterialType;

			UINT8 MaterialID;
			bsData.Read(MaterialID);
			q.MaterialData.mData.MaterialID = MaterialID;

			if (q.MaterialData.mData.MaterialType == 1) // Texture Normal
			{
				BYTE libraryNameLen;
				BYTE textureNameLen;

				UINT16 ModelID;
				bsData.Read(ModelID);
				q.MaterialData.mData.ModelID = ModelID;

				bsData.Read(libraryNameLen);
				char libraryName[128];
				bsData.Read(libraryName, libraryNameLen);
				libraryName[libraryNameLen] = '\0';

				strcpy(q.MaterialData.mData.libraryName, libraryName);

				bsData.Read(textureNameLen);
				char textureName[128];
				bsData.Read(textureName, textureNameLen);
				textureName[textureNameLen] = '\0';

				strcpy(q.MaterialData.mData.textureName, textureName);

				bsData.Read(q.MaterialData.mData.color);
			}
			else if (q.MaterialData.mData.MaterialType == 2) // Texture Text/Material Text
			{
				BYTE fontNameLength;

				UINT8 MaterialSize;
				bsData.Read(MaterialSize);
				q.MaterialData.mData.MaterialSize = MaterialSize;

				bsData.Read(fontNameLength);
				char fontName[128];
				bsData.Read(fontName, fontNameLength);
				fontName[fontNameLength] = '\0';
				strcpy(q.MaterialData.mData.fontName, fontName);

				UINT8 FontSize;
				
				bsData.Read(FontSize);
				q.MaterialData.mData.FontSize = FontSize;

				UINT8 Bold;
				bsData.Read(Bold);
				q.MaterialData.mData.Bold = Bold;

				DWORD FontColor;
				bsData.Read(FontColor);
				q.MaterialData.mData.FontColor = FontColor;

				DWORD BackgroundColor;
				bsData.Read(BackgroundColor);
				q.MaterialData.mData.BackgroundColor = BackgroundColor;

				UINT8 Align;
				bsData.Read(Align);
				q.MaterialData.mData.Align = Align;

				sprintf(q.MaterialData.mData.Text, "Text_%d%d%d", q.MaterialData.mData.Bold, q.MaterialData.objectID, q.MaterialData.mData.Align);
			}

			QueuePrc.enqueue(q);
		}
	}
	callback(rpcParams);
}

bool OnReceivePacket(Packet* p)
{
	if (p->data == nullptr || p->length == 0)
		return true;
	
	if (p->data[0] == PacketEnumeration::ID_VEHICLE_SYNC) // Example.
	{
		
	}
	return true;
}


BOOL WINAPI DllMain(
	HINSTANCE hinstDLL, 
	DWORD fdwReason,    
	LPVOID lpReserved) 
{

	g_DllHandle = hinstDLL;

	DisableThreadLibraryCalls((HMODULE)hinstDLL);

	if (fdwReason != DLL_PROCESS_ATTACH)
		return FALSE;

	if (GetModuleHandle("samp.dll"))
	{
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThrMainFS, NULL, 0, NULL);
	}

	return TRUE;  
}